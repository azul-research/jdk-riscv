/*
 * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.
 * Copyright (c) 2012, 2018 SAP SE. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 *
 */


#include "precompiled.hpp"
#include "asm/macroAssembler.inline.hpp"
#include "gc/shared/barrierSet.hpp"
#include "gc/shared/barrierSetAssembler.hpp"
#include "interp_masm_riscv.hpp"
#include "interpreter/interpreterRuntime.hpp"
#include "prims/jvmtiThreadState.hpp"
#include "runtime/frame.inline.hpp"
#include "runtime/safepointMechanism.hpp"
#include "runtime/sharedRuntime.hpp"

// Implementation of InterpreterMacroAssembler.

// This file specializes the assembler with interpreter-specific macros.

#ifdef PRODUCT
#define BLOCK_COMMENT(str) // nothing
#else
#define BLOCK_COMMENT(str) block_comment(str)
#endif

void InterpreterMacroAssembler::null_check_throw(Register a, int offset, Register temp_reg) {
  address exception_entry = Interpreter::throw_NullPointerException_entry();
  MacroAssembler::null_check_throw(a, offset, temp_reg, exception_entry);
}

void InterpreterMacroAssembler::jump_to_entry(address entry, Register Rscratch) {
  assert(entry, "Entry must have been generated by now");
  if (is_within_range_of_b(entry, pc())) {
    b_PPC(entry);
  } else {
    load_const_optimized(Rscratch, entry, R0);
    mtctr_PPC(Rscratch);
    bctr_PPC();
  }
}

void InterpreterMacroAssembler::dispatch_next(TosState state, int bcp_incr, bool generate_poll) {
  Register bytecode = R6_scratch2;

  lbu(bytecode, R22_bcp, bcp_incr);
  if (bcp_incr != 0) addi(R22_bcp, R22_bcp, bcp_incr);

  address* add0 = Interpreter::dispatch_table(state);

  dispatch_Lbyte_code(state, bytecode, add0, generate_poll);
}

void InterpreterMacroAssembler::dispatch_via(TosState state, address* table) {
  // Load current bytecode.
  Register bytecode = R6_scratch2;
  lbz_PPC(bytecode, 0, R22_bcp);
  dispatch_Lbyte_code(state, bytecode, table);
}

// Dispatch code executed in the prolog of a bytecode which does not do it's
// own dispatch. The dispatch address is computed and placed in R24_dispatch_addr_PPC.
void InterpreterMacroAssembler::dispatch_prolog(TosState state, int bcp_incr) {
}

// Dispatch code executed in the epilog of a bytecode which does not do it's
// own dispatch. The dispatch address in R24_dispatch_addr_PPC is used for the
// dispatch.
void InterpreterMacroAssembler::dispatch_epilog(TosState state, int bcp_incr) {
  Register bytecode = R29_TMP4;
  lbu(bytecode, R22_bcp, bcp_incr);
  load_dispatch_table(R30_TMP5, Interpreter::dispatch_table(state));
  slli(bytecode, bytecode, LogBytesPerWord);
  add(R30_TMP5, R30_TMP5, bytecode);
  ld(R30_TMP5, R30_TMP5, 0);

  if (bcp_incr) { addi(R22_bcp, R22_bcp, bcp_incr); }
  jr(R30_TMP5);
}

void InterpreterMacroAssembler::check_and_handle_popframe(Register Rscratch1, Register Rscratch2) {
  assert(Rscratch1 != R0, "can't use R0 as scratch_reg here");
  if (JvmtiExport::can_pop_frame()) {
    Label L;

    // Check the "pending popframe condition" flag in the current thread.
    lwu(Rscratch1, R24_thread, in_bytes(JavaThread::popframe_condition_offset()));

    // Initiate popframe handling only if it is not already being
    // processed. If the flag has the popframe_processing bit set, it
    // means that this code is called *during* popframe handling - we
    // don't want to reenter.
    andi(Rscratch2, Rscratch1, JavaThread::popframe_pending_bit);
    beqz(Rscratch2, L);

    andi(Rscratch2, Rscratch1, JavaThread::popframe_processing_bit);
    bnez(Rscratch2, L);

    // Call the Interpreter::remove_activation_preserving_args_entry()
    // func to get the address of the same-named entrypoint in the
    // generated interpreter code.
    call_c(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_preserving_args_entry), relocInfo::none);

    // Jump to Interpreter::_remove_activation_preserving_args_entry.
    jr(R10_RET1);

    align(32, 12);
    bind(L);
  }
}

void InterpreterMacroAssembler::check_and_handle_earlyret(Register Rscratch1, Register Rscratch2) {
  const Register Rthr_state_addr = Rscratch1;
  if (JvmtiExport::can_force_early_return()) {
    untested("early return is not tested");
    Label Lno_early_ret;
    ld(Rthr_state_addr, R24_thread, in_bytes(JavaThread::jvmti_thread_state_offset()));
    beqz(Rthr_state_addr, Lno_early_ret);

    lwu(Rscratch2, Rthr_state_addr, in_bytes(JvmtiThreadState::earlyret_state_offset()));
    // JvmtiThreadState::earlyret_pending is small enough to fit here
    addi(Rscratch2, Rscratch2, -((int) JvmtiThreadState::earlyret_pending));
    bnez(Rscratch2, Lno_early_ret);

    // Jump to Interpreter::_earlyret_entry.
    lwu(R10_ARG0, Rthr_state_addr, in_bytes(JvmtiThreadState::earlyret_tos_offset()));
    call_VM_leaf(CAST_FROM_FN_PTR(address, Interpreter::remove_activation_early_entry));
    jr(R10_RET1);

    align(32, 12);
    bind(Lno_early_ret);
  }
}

void InterpreterMacroAssembler::load_earlyret_value(TosState state, Register Rscratch1) {
  const Register RjvmtiState = Rscratch1;
  const Register Rscratch2   = R0;

  ld_PPC(RjvmtiState, in_bytes(JavaThread::jvmti_thread_state_offset()), R24_thread);
  li_PPC(Rscratch2, 0);

  switch (state) {
    case atos: ld_PPC(R25_tos, in_bytes(JvmtiThreadState::earlyret_oop_offset()), RjvmtiState);
               std_PPC(Rscratch2, in_bytes(JvmtiThreadState::earlyret_oop_offset()), RjvmtiState);
               break;
    case ltos: ld_PPC(R25_tos, in_bytes(JvmtiThreadState::earlyret_value_offset()), RjvmtiState);
               break;
    case btos: // fall through
    case ztos: // fall through
    case ctos: // fall through
    case stos: // fall through
    case itos: lwz_PPC(R25_tos, in_bytes(JvmtiThreadState::earlyret_value_offset()), RjvmtiState);
               break;
    case ftos: lfs_PPC(F23_ftos, in_bytes(JvmtiThreadState::earlyret_value_offset()), RjvmtiState);
               break;
    case dtos: lfd_PPC(F23_ftos, in_bytes(JvmtiThreadState::earlyret_value_offset()), RjvmtiState);
               break;
    case vtos: break;
    default  : ShouldNotReachHere();
  }

  // Clean up tos value in the jvmti thread state.
  std_PPC(Rscratch2, in_bytes(JvmtiThreadState::earlyret_value_offset()), RjvmtiState);
  // Set tos state field to illegal value.
  li_PPC(Rscratch2, ilgl);
  stw_PPC(Rscratch2, in_bytes(JvmtiThreadState::earlyret_tos_offset()), RjvmtiState);
}

// Common code to dispatch and dispatch_only.
// Dispatch value in Lbyte_code and increment Lbcp.

void InterpreterMacroAssembler::load_dispatch_table(Register dst, address* table) {
  address table_base = (address)Interpreter::dispatch_table((TosState)0);
  intptr_t table_offs = (intptr_t)table - (intptr_t)table_base;
  if (is_simm12(table_offs)) {
    addi(dst, R19_templateTableBase, (int)table_offs);
  } else {
    li(dst, table);
  }
}

void InterpreterMacroAssembler::dispatch_Lbyte_code(TosState state, Register bytecode,
                                                    address* table, bool generate_poll) {
  assert_different_registers(bytecode, R5_scratch1);
  Label dispatch, skip;

#if 0   // FIXME_RISCV: uncomment when safepoints are implemented
  if (SafepointMechanism::uses_thread_local_poll() && generate_poll) {
    address *sfpt_tbl = Interpreter::safept_table(state);
    if (table != sfpt_tbl) {
      ld(R5_scratch1, R24_thread, in_bytes(Thread::polling_page_offset()));
      // Armed page has poll_bit qset, if poll bit is cleared just continue.
      andi(R5_scratch1, R5_scratch1, (int) SafepointMechanism::poll_bit());
      beqz(R5_scratch1, dispatch);
      load_dispatch_table(R5_scratch1, sfpt_tbl);
      j(skip);
    }
  }
#endif

  // Calc dispatch table address.
  bind(dispatch);
  load_dispatch_table(R5_scratch1, table);
  bind(skip);

  slli(R6_scratch2, bytecode, LogBytesPerWord);
  add(R6_scratch2, R6_scratch2, R5_scratch1);
  ld(R5_scratch1, R6_scratch2, 0);

  // Jump off!
  jr(R5_scratch1);
}

void InterpreterMacroAssembler::load_receiver(Register Rparam_count, Register Rrecv_dst) {
  slli(Rrecv_dst, Rparam_count, Interpreter::logStackElementSize);
  ld(Rrecv_dst, Rrecv_dst, R23_esp);
}

// helpers for expression stack

void InterpreterMacroAssembler::pop_i(Register r) {
  lw(r, R23_esp, Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::pop_ptr(Register r) {
  ld(r, R23_esp, Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::pop_l(Register r) {
  ld(r, R23_esp, Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, 2 * Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::pop_f(FloatRegister f) {
  flw(f, R23_esp, Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::pop_d(FloatRegister f) {
  fld(f, R23_esp, Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, 2 * Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_i(Register r) {
  sw(r, R23_esp, 0);
  addi(R23_esp, R23_esp, -Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_ptr(Register r) {
  sd(r, R23_esp, 0);
  addi(R23_esp, R23_esp, -Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_l(Register r) {
  sd(R0_ZERO, R23_esp, 0);
  sd(r, R23_esp, -Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, -2 * Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_f(FloatRegister f) {
  fsw(f, R23_esp, 0);
  addi(R23_esp, R23_esp, -Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_d(FloatRegister f)   {
  fsd(f, R23_esp, -Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, -2 * Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::push_2ptrs(Register first, Register second) {
  sd(first, R23_esp, 0);
  sd(second, R23_esp, -Interpreter::stackElementSize);
  addi(R23_esp, R23_esp, -2 * Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::move_l_to_d(Register l, FloatRegister d) {
  fmvdx(d, l);
}

void InterpreterMacroAssembler::move_d_to_l(FloatRegister d, Register l) {
  fmvxd(l, d);
}

void InterpreterMacroAssembler::push(TosState state) {
  switch (state) {
    case atos: push_ptr();                break;
    case btos:
    case ztos:
    case ctos:
    case stos:
    case itos: push_i();                  break;
    case ltos: push_l();                  break;
    case ftos: push_f();                  break;
    case dtos: push_d();                  break;
    case vtos: /* nothing to do */        break;
    default  : ShouldNotReachHere();
  }
}

void InterpreterMacroAssembler::pop(TosState state) {
  switch (state) {
    case atos: pop_ptr();            break;
    case btos:
    case ztos:
    case ctos:
    case stos:
    case itos: pop_i();              break;
    case ltos: pop_l();              break;
    case ftos: pop_f();              break;
    case dtos: pop_d();              break;
    case vtos: /* nothing to do */   break;
    default  : ShouldNotReachHere();
  }
  verify_oop(R25_tos, state);
}

void InterpreterMacroAssembler::empty_expression_stack() {
  addi_PPC(R23_esp, R26_monitor_PPC, - Interpreter::stackElementSize);
}

void InterpreterMacroAssembler::get_2_byte_integer_at_bcp(int         bcp_offset,
                                                          Register    Rdst,
                                                          signedOrNot is_signed) {
#if defined(VM_LITTLE_ENDIAN)
  Register Rtmp = R30_TMP5;
  if (Rdst == Rtmp) Rtmp = R29_TMP4;

  if (is_signed == Signed) {
    lb(Rtmp, R22_bcp, bcp_offset);
  } else {
    lbu(Rtmp, R22_bcp, bcp_offset);
  }
  slli(Rtmp, Rtmp, 8);
  lbu(Rdst, R22_bcp, bcp_offset + 1);
  orr(Rdst, Rtmp, Rdst);
#else
  // Read Java big endian format.
  if (is_signed == Signed) {
    lh(Rdst, R22_bcp, bcp_offset);
  } else {
    lhu(Rdst, R22_bcp, bcp_offset);
  }
#endif
}

void InterpreterMacroAssembler::get_4_byte_integer_at_bcp(int         bcp_offset,
                                                          Register    Rdst,
                                                          signedOrNot is_signed) {
#if defined(VM_LITTLE_ENDIAN)
  Register Rtmp = R30_TMP5;
  if (Rdst == Rtmp) Rtmp = R29_TMP4;

  if (is_signed == Signed) {
    lb(Rdst, R22_bcp, bcp_offset);
  } else {
    lbu(Rdst, R22_bcp, bcp_offset);
  }

  for (int i = 1; i <= 3; ++i) {
    slli(Rdst, Rdst, 8);
    lbu(Rtmp, R22_bcp, bcp_offset + i);
    orr(Rdst, Rtmp, Rdst);
  }
#else
  // Read Java big endian format.
  // FIXME_RISCV: alignment problems might occur
  if (is_signed == Signed) {
    lw(Rdst, R22_bcp, bcp_offset);
  } else {
    lwu(Rdst, R22_bcp, bcp_offset);
  }
#endif
}


// Load the constant pool cache index from the bytecode stream.
//
// Kills / writes:
//   - Rdst, Rscratch
void InterpreterMacroAssembler::get_cache_index_at_bcp(Register Rdst, int bcp_offset,
                                                       size_t index_size) {
  assert(bcp_offset > 0, "bcp is still pointing to start of bytecode");
  // Cache index is always in the native format, courtesy of Rewriter.
  if (index_size == sizeof(u2)) {
    lhu(Rdst, R22_bcp,  bcp_offset);
  } else if (index_size == sizeof(u4)) {
    li(Rdst, bcp_offset);
    add(Rdst, Rdst, R22_bcp);
    lw(Rdst, Rdst, 0);
    assert(ConstantPool::decode_invokedynamic_index(~123) == 123, "else change next line");
    xori(Rdst, Rdst, -1); // convert to plain index
  } else if (index_size == sizeof(u1)) {
    lbu(Rdst, R22_bcp, bcp_offset);
  } else {
    ShouldNotReachHere();
  }
  // Rdst now contains cp cache index.
}

void InterpreterMacroAssembler::get_cache_and_index_at_bcp(Register cache, int bcp_offset,
                                                           size_t index_size) {
  get_cache_index_at_bcp(cache, bcp_offset, index_size);
  slli(cache, cache, exact_log2(in_words(ConstantPoolCacheEntry::size()) * BytesPerWord));
  add(cache, R9_constPoolCache, cache);
}

// Load 4-byte signed or unsigned integer in Java format (that is, big-endian format)
// from (Rsrc)+offset.
void InterpreterMacroAssembler::get_u4(Register Rdst, Register Rsrc, int offset,
                                       signedOrNot is_signed) {
#if defined(VM_LITTLE_ENDIAN)
  assert_different_registers(Rdst, Rsrc);
  Register Rtmp = R30_TMP5;
  if (Rdst == Rtmp || Rsrc == Rtmp) Rtmp = R29_TMP4;
  if (Rdst == Rtmp || Rsrc == Rtmp) Rtmp = R28_TMP3;

  if (is_signed == Signed) {
    lb(Rdst, Rsrc, offset);
  } else {
    lbu(Rdst, Rsrc, offset);
  }

  for (int i = 1; i <= 3; ++i) {
    slli(Rdst, Rdst, 8);
    lbu(Rtmp, Rsrc, offset + i);
    orr(Rdst, Rtmp, Rdst);
  }
#else
  if (is_signed == Signed) {
    lw(Rdst, offset, Rsrc);
  } else {
    lwu(Rdst, offset, Rsrc);
  }
#endif
}

// Load object from cpool->resolved_references(index).
void InterpreterMacroAssembler::load_resolved_reference_at_index(Register result, Register index, Label *L_handle_null) {
  assert_different_registers(result, index);

  get_constant_pool(result);

  // Convert from field index to resolved_references() index and from
  // word index to byte offset. Since this is a java object, it can be compressed.
  Register tmp = index;  // reuse
  slli(tmp, index, LogBytesPerHeapOop);
  // Load pointer for resolved_references[] objArray.
  ld(result, result, ConstantPool::cache_offset_in_bytes());
  ld(result, result, ConstantPoolCache::resolved_references_offset_in_bytes());

  resolve_oop_handle(result);
#ifdef ASSERT
  /* FixME RISCV
  Label index_ok;
  lwa_PPC(R0, arrayOopDesc::length_offset_in_bytes(), result);
  sldi_PPC(R0, R0, LogBytesPerHeapOop);
  cmpd_PPC(CCR0, tmp, R0);
  blt_PPC(CCR0, index_ok);
  stop("resolved reference index out of bounds", 0x09256);
  bind(index_ok);
  */
#endif
  // Add in the index.
  add(result, tmp, result);

  load_heap_oop(result, arrayOopDesc::base_offset_in_bytes(T_OBJECT), result, tmp, R0, false, 0, L_handle_null);
}

// load cpool->resolved_klass_at(index)
void InterpreterMacroAssembler::load_resolved_klass_at_offset(Register Rcpool, Register Roffset, Register Rklass) {
  // int value = *(Rcpool->int_at_addr(which));
  // int resolved_klass_index = extract_low_short_from_int(value);
  //add_PPC(Roffset, Rcpool, Roffset);
  add(Roffset, Rcpool, Roffset);
#if defined(VM_LITTLE_ENDIAN)
  printf("load_resolved_klass_at_offset-1.1: %p\n", pc());
  lhu(Roffset, Roffset, sizeof(ConstantPool));
//  lhz_PPC(Roffset, sizeof(ConstantPool), Roffset);     // Roffset = resolved_klass_index
#else
  printf("load_resolved_klass_at_offset-1.2: %p\n", pc());

  unimplemented("load_resolved_klass_at_offset bigendian");
  lhz_PPC(Roffset, sizeof(ConstantPool) + 2, Roffset); // Roffset = resolved_klass_index
#endif
  printf("load_resolved_klass_at_offset-2: %p\n", pc());

//  ld_PPC(Rklass, ConstantPool::resolved_klasses_offset_in_bytes(), Rcpool); // Rklass = Rcpool->_resolved_klasses

  ld(Rklass, Rcpool, ConstantPool::resolved_klasses_offset_in_bytes()); // Rklass = Rcpool->_resolved_klasses

  printf("load_resolved_klass_at_offset-3: %p\n", pc());

//  sldi_PPC(Roffset, Roffset, LogBytesPerWord);
  slli(Roffset, Roffset, LogBytesPerWord);

//  addi_PPC(Roffset, Roffset, Array<Klass*>::base_offset_in_bytes());
  addi(Roffset, Roffset, Array<Klass*>::base_offset_in_bytes());

 // isync_PPC(); // Order load of instance Klass wrt. tags.
 acquire();

//  ldx_PPC(Rklass, Rklass, Roffset);
  ld(Rklass, Rklass, Roffset);
}

void InterpreterMacroAssembler::load_resolved_method_at_index(int byte_no,
                                                              Register cache,
                                                              Register method) {
  const int method_offset = in_bytes(
    ConstantPoolCache::base_offset() +
      ((byte_no == TemplateTable::f2_byte)
       ? ConstantPoolCacheEntry::f2_offset()
       : ConstantPoolCacheEntry::f1_offset()));

  ld(method, cache, method_offset); // get f1 Method*
}

// Generate a subtype check: branch to ok_is_subtype if sub_klass is
// a subtype of super_klass. Blows registers Rsub_klass, tmp1, tmp2.
void InterpreterMacroAssembler::gen_subtype_check(Register Rsub_klass, Register Rsuper_klass, Register Rtmp1,
                                                  Register Rtmp2, Register Rtmp3, Label &ok_is_subtype) {
  // Profile the not-null value's klass.
  profile_typecheck(Rsub_klass, Rtmp1, Rtmp2);
  check_klass_subtype(Rsub_klass, Rsuper_klass, Rtmp1, Rtmp2, ok_is_subtype);
  profile_typecheck_failed(Rtmp1, Rtmp2);
}

// Separate these two to allow for delay slot in middle.
// These are used to do a test and full jump to exception-throwing code.

// Check that index is in range for array, then shift index by index_shift,
// and put arrayOop + shifted_index into res.
// Note: res is still shy of address by array offset into object.

void InterpreterMacroAssembler::index_check_without_pop(Register Rarray, Register Rindex,
                                                        int index_shift, Register Rtmp, Register Rres) {
  // Check that index is in range for array, then shift index by index_shift,
  // and put arrayOop + shifted_index into res.
  // Note: res is still shy of address by array offset into object.
  // Kills:
  //   - Rindex
  // Writes:
  //   - Rres: Address that corresponds to the array index if check was successful.
  verify_oop(Rarray);
  const Register Rlength   = R6_scratch2;
  const Register RsxtIndex = Rtmp;
  assert_different_registers(Rlength, Rarray, Rindex, Rtmp);
  Label LisNull, LnotOOR;

  // Array nullcheck
  if (!ImplicitNullChecks) {
    beqz(Rarray, LisNull);
  } else {
    //null_check_throw(Rarray, arrayOopDesc::length_offset_in_bytes(), /*temp*/RsxtIndex); FIXME_RISCV
  }

  // Index check
  lwu(Rlength, Rarray, arrayOopDesc::length_offset_in_bytes());
  blt(Rindex, Rlength, LnotOOR);
  // Index should be in R25_tos, array should be in R11_ARG1
  mv_if_needed(R25_tos, Rindex);
  mv_if_needed(R11_ARG1, Rarray);
  load_dispatch_table(Rtmp, (address*)Interpreter::_throw_ArrayIndexOutOfBoundsException_entry);
  jr(Rtmp);

  if (!ImplicitNullChecks) {
    bind(LisNull);
    load_dispatch_table(Rtmp, (address*)Interpreter::_throw_NullPointerException_entry);
    jr(Rtmp);
  }

  align(32, 16);
  bind(LnotOOR);
  slli(RsxtIndex, Rindex, index_shift);
  // Calc address
  add(Rres, RsxtIndex, Rarray);
}

void InterpreterMacroAssembler::index_check(Register array, Register index,
                                            int index_shift, Register tmp, Register res) {
  // pop array
  pop_ptr(array);

  // check array
  index_check_without_pop(array, index, index_shift, tmp, res);
}

void InterpreterMacroAssembler::get_const(Register Rdst) {
  ld(Rdst, R27_method, in_bytes(Method::const_offset()));
}

void InterpreterMacroAssembler::get_constant_pool(Register Rdst) {
  get_const(Rdst);
  ld(Rdst, Rdst, in_bytes(ConstMethod::constants_offset()));
}

void InterpreterMacroAssembler::get_constant_pool_cache(Register Rdst) {
  get_constant_pool(Rdst);
  ld(Rdst, Rdst, ConstantPool::cache_offset_in_bytes());
}

void InterpreterMacroAssembler::get_cpool_and_tags(Register Rcpool, Register Rtags) {
  get_constant_pool(Rcpool);
  ld(Rtags, Rcpool, ConstantPool::tags_offset_in_bytes());
}

// Unlock if synchronized method.
//
// Unlock the receiver if this is a synchronized method.
// Unlock any Java monitors from synchronized blocks.
//
// If there are locked Java monitors
//   If throw_monitor_exception
//     throws IllegalMonitorStateException
//   Else if install_monitor_exception
//     installs IllegalMonitorStateException
//   Else
//     no error processing
void InterpreterMacroAssembler::unlock_if_synchronized_method(TosState state,
                                                              bool throw_monitor_exception,
                                                              bool install_monitor_exception) {
  Label Lunlocked, Lno_unlock;
  {
    Register Rdo_not_unlock_flag = R5_scratch1;
    Register Raccess_flags       = R6_scratch2;

    // Check if synchronized method or unlocking prevented by
    // JavaThread::do_not_unlock_if_synchronized flag.
    lbz_PPC(Rdo_not_unlock_flag, in_bytes(JavaThread::do_not_unlock_if_synchronized_offset()), R24_thread);
    lwz_PPC(Raccess_flags, in_bytes(Method::access_flags_offset()), R27_method);
    li_PPC(R0, 0);
    stb_PPC(R0, in_bytes(JavaThread::do_not_unlock_if_synchronized_offset()), R24_thread); // reset flag

    push(state);

    // Skip if we don't have to unlock.
    rldicl__PPC(R0, Raccess_flags, 64-JVM_ACC_SYNCHRONIZED_BIT, 63); // Extract bit and compare to 0.
    beq_PPC(CCR0, Lunlocked);

    cmpwi_PPC(CCR0, Rdo_not_unlock_flag, 0);
    bne_PPC(CCR0, Lno_unlock);
  }

  // Unlock
  {
    Register Rmonitor_base = R5_scratch1;

    Label Lunlock;
    // If it's still locked, everything is ok, unlock it.
    ld_PPC(Rmonitor_base, 0, R1_SP_PPC);
    addi_PPC(Rmonitor_base, Rmonitor_base,
         -(frame::ijava_state_size + frame::interpreter_frame_monitor_size_in_bytes())); // Monitor base

    ld_PPC(R0, BasicObjectLock::obj_offset_in_bytes(), Rmonitor_base);
    cmpdi_PPC(CCR0, R0, 0);
    bne_PPC(CCR0, Lunlock);

    // If it's already unlocked, throw exception.
    if (throw_monitor_exception) {
      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_illegal_monitor_state_exception));
      should_not_reach_here();
    } else {
      if (install_monitor_exception) {
        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::new_illegal_monitor_state_exception));
        b_PPC(Lunlocked);
      }
    }

    bind(Lunlock);
    unlock_object(Rmonitor_base);
  }

  // Check that all other monitors are unlocked. Throw IllegelMonitorState exception if not.
  bind(Lunlocked);
  {
    Label Lexception, Lrestart;
    Register Rcurrent_obj_addr = R5_scratch1;
    const int delta = frame::interpreter_frame_monitor_size_in_bytes();
    assert((delta & LongAlignmentMask) == 0, "sizeof BasicObjectLock must be even number of doublewords");

    bind(Lrestart);
    // Set up search loop: Calc num of iterations.
    {
      Register Riterations = R6_scratch2;
      Register Rmonitor_base = Rcurrent_obj_addr;
      ld_PPC(Rmonitor_base, 0, R1_SP_PPC);
      addi_PPC(Rmonitor_base, Rmonitor_base, - frame::ijava_state_size);  // Monitor base

      subf__PPC(Riterations, R26_monitor_PPC, Rmonitor_base);
      ble_PPC(CCR0, Lno_unlock);

      addi_PPC(Rcurrent_obj_addr, Rmonitor_base,
           BasicObjectLock::obj_offset_in_bytes() - frame::interpreter_frame_monitor_size_in_bytes());
      // Check if any monitor is on stack, bail out if not
      srdi_PPC(Riterations, Riterations, exact_log2(delta));
      mtctr_PPC(Riterations);
    }

    // The search loop: Look for locked monitors.
    {
      const Register Rcurrent_obj = R0;
      Label Lloop;

      ld_PPC(Rcurrent_obj, 0, Rcurrent_obj_addr);
      addi_PPC(Rcurrent_obj_addr, Rcurrent_obj_addr, -delta);
      bind(Lloop);

      // Check if current entry is used.
      cmpdi_PPC(CCR0, Rcurrent_obj, 0);
      bne_PPC(CCR0, Lexception);
      // Preload next iteration's compare value.
      ld_PPC(Rcurrent_obj, 0, Rcurrent_obj_addr);
      addi_PPC(Rcurrent_obj_addr, Rcurrent_obj_addr, -delta);
      bdnz_PPC(Lloop);
    }
    // Fell through: Everything's unlocked => finish.
    b_PPC(Lno_unlock);

    // An object is still locked => need to throw exception.
    bind(Lexception);
    if (throw_monitor_exception) {
      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_illegal_monitor_state_exception));
      should_not_reach_here();
    } else {
      // Stack unrolling. Unlock object and if requested, install illegal_monitor_exception.
      // Unlock does not block, so don't have to worry about the frame.
      Register Rmonitor_addr = R5_scratch1;
      addi_PPC(Rmonitor_addr, Rcurrent_obj_addr, -BasicObjectLock::obj_offset_in_bytes() + delta);
      unlock_object(Rmonitor_addr);
      if (install_monitor_exception) {
        call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::new_illegal_monitor_state_exception));
      }
      b_PPC(Lrestart);
    }
  }

  align(32, 12);
  bind(Lno_unlock);
  pop(state);
}

void InterpreterMacroAssembler::narrow(Register result) {
  Register ret_type = R5_scratch1;
  Register scratch = R6_scratch2;
  ld(R5_scratch1, R27_method, in_bytes(Method::const_offset()));
  lbu(ret_type, R5_scratch1, in_bytes(ConstMethod::result_type_offset()));

  Label notBool, notByte, notChar, byteOne, shortOne, done;

  // common case first
  li(scratch, T_INT);
  beq(scratch, ret_type, done);

  li(scratch, T_BOOLEAN);
  bne(scratch, ret_type, notBool);
  andi(result, result, 0x1);
  j(done);

  bind(notBool);
  li(scratch, T_BYTE);
  bne(scratch, ret_type, notByte);
  // sign-extend lower 8 bits
  slli(result, result, 56);
  srai(result, result, 56);
  j(done);

  bind(notByte);
  addi(scratch, R0, T_CHAR);
  bne(scratch, ret_type, notChar);
  // truncate all but lower 16 bits
  slli(result, result, 48);
  srli(result, result, 48);
  j(done);

  bind(notChar);
  // sign-extend lower 16 bits
  slli(result, result, 48);
  srai(result, result, 48);

  // Nothing to do for T_INT
  bind(done);
}

// Remove activation.
//
// Unlock the receiver if this is a synchronized method.
// Unlock any Java monitors from synchronized blocks.
// Remove the activation from the stack.
//
// If there are locked Java monitors
//    If throw_monitor_exception
//       throws IllegalMonitorStateException
//    Else if install_monitor_exception
//       installs IllegalMonitorStateException
//    Else
//       no error processing
void InterpreterMacroAssembler::remove_activation(TosState state,
                                                  bool throw_monitor_exception,
                                                  bool install_monitor_exception) {
  BLOCK_COMMENT("remove_activation {");
#if 0 // TODO_RISCV
  unlock_if_synchronized_method(state, throw_monitor_exception, install_monitor_exception);
#endif

  // Save result (push state before jvmti call and pop it afterwards) and notify jvmti.
  notify_method_exit(false, state, NotifyJVMTI, true);

#if 0 // TODO_RISCV
  BLOCK_COMMENT("reserved_stack_check:");
  if (StackReservedPages > 0) {
    // Test if reserved zone needs to be enabled.
    Label no_reserved_zone_enabling;

    // Compare frame pointers. There is no good stack pointer, as with stack
    // frame compression we can get different SPs when we do calls. A subsequent
    // call could have a smaller SP, so that this compare succeeds for an
    // inner call of the method annotated with ReservedStack.
    ld_ptr_PPC(R0, JavaThread::reserved_stack_activation_offset(), R24_thread);
    ld_ptr_PPC(R5_scratch1, _abi_PPC(callers_sp), R1_SP_PPC); // Load frame pointer.
    cmpld_PPC(CCR0, R5_scratch1, R0);
    blt_predict_taken_PPC(CCR0, no_reserved_zone_enabling);

    // Enable reserved zone again, throw stack overflow exception.
    call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::enable_stack_reserved_zone), R24_thread);
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::throw_delayed_StackOverflowError));

    should_not_reach_here();

    bind(no_reserved_zone_enabling);
  }
#endif

  verify_oop(R25_tos, state);
  verify_thread();

  pop_java_frame();
  BLOCK_COMMENT("} remove_activation");
}

// Lock object
//
// Registers alive
//   monitor - Address of the BasicObjectLock to be used for locking,
//             which must be initialized with the object to lock.
//   object  - Address of the object to be locked.
//
void InterpreterMacroAssembler::lock_object(Register monitor, Register object) {
  if (UseHeavyMonitors) {
    addi(monitor, monitor, 0);
    addi(object, object, 0);
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
            monitor, /*check_for_exceptions=*/true);
  } else {
    // template code:
    //
    // markOop displaced_header = obj->mark().set_unlocked();
    // monitor->lock()->set_displaced_header(displaced_header);
    // if (Atomic::cmpxchg(/*ex=*/monitor, /*addr*/obj->mark_addr(), /*cmp*/displaced_header) == displaced_header) {
    //   // We stored the monitor address into the object's mark word.
    // } else if (THREAD->is_lock_owned((address)displaced_header))
    //   // Simple recursive case.
    //   monitor->lock()->set_displaced_header(NULL);
    // } else {
    //   // Slow path.
    //   InterpreterRuntime::monitorenter(THREAD, monitor);
    // };

    const Register displaced_header = R14_ARG4;
    const Register object_mark_addr = R15_ARG5;
    const Register current_header   = R16_ARG6;
    const Register tmp              = R17_ARG7;

    Label done;
    Label cas_failed, slow_case;

    assert_different_registers(displaced_header, object_mark_addr, current_header, tmp);

    // markOop displaced_header = obj->mark().set_unlocked();

    // Load markOop from object into displaced_header.
    ld(displaced_header, object, oopDesc::mark_offset_in_bytes());

    if (UseBiasedLocking) {
      unimplemented("Biased locking is not implemented");
      biased_locking_enter(CCR0, object, displaced_header, tmp, current_header, done, &slow_case);
    }

    // Set displaced_header to be (markOop of object | UNLOCK_VALUE).
    ori(displaced_header, displaced_header, markOopDesc::unlocked_value);

    // monitor->lock()->set_displaced_header(displaced_header);

    // Initialize the box (Must happen before we update the object mark!).
    sd(displaced_header, monitor, BasicObjectLock::lock_offset_in_bytes() + BasicLock::displaced_header_offset_in_bytes());

    // if (Atomic::cmpxchg(/*ex=*/monitor, /*addr*/obj->mark_addr(), /*cmp*/displaced_header) == displaced_header) {

    // Store stack address of the BasicObjectLock (this is monitor) into object.
    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());

    // Must fence, otherwise, preceding store(s) may float below cmpxchg.
    // CmpxchgX sets CCR0 to cmpX(current, displaced).
    cmpxchg_for_lock_acquire(/*current_value=*/current_header, /*compare_value=*/displaced_header,
                             /*exchange_value=*/monitor, /*where=*/object_mark_addr, tmp,  &cas_failed);

    // If the compare-and-exchange succeeded, then we found an unlocked
    // object and we have now locked it.
    j(done);
    bind(cas_failed);

    // } else if (THREAD->is_lock_owned((address)displaced_header))
    //   // Simple recursive case.
    //   monitor->lock()->set_displaced_header(NULL);

    // We did not see an unlocked object so try the fast recursive case.

    // Check if owner is self by comparing the value in the markOop of object
    // (current_header) with the stack pointer.
    sub(current_header, current_header, R2_SP);

    assert(os::vm_page_size() > 0xfff, "page size too small - change the constant");
    load_const_optimized(tmp, ~(os::vm_page_size()-1) | markOopDesc::lock_mask_in_place);

    andr(tmp, current_header, tmp);
    // If condition is true we are done and hence we can store 0 in the displaced
    // header indicating it is a recursive lock.
    bnez(tmp, slow_case);
    sd(R0_ZERO, monitor, BasicObjectLock::lock_offset_in_bytes() + BasicLock::displaced_header_offset_in_bytes());
    j(done);

    // } else {
    //   // Slow path.
    //   InterpreterRuntime::monitorenter(THREAD, monitor);

    // None of the above fast optimizations worked so we have to get into the
    // slow case of monitor enter.
    bind(slow_case);
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),
            monitor, /*check_for_exceptions=*/true);
    // }
    align(32, 12);
    bind(done);
  }
}

// Unlocks an object. Used in monitorexit bytecode and remove_activation.
//
// Registers alive
//   monitor - Address of the BasicObjectLock to be used for locking,
//             which must be initialized with the object to lock.
//
// Throw IllegalMonitorException if object is not locked by current thread.
void InterpreterMacroAssembler::unlock_object(Register monitor, bool check_for_exceptions) {
  if (UseHeavyMonitors) {
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit),
            monitor, check_for_exceptions);
  } else {

    // template code:
    //
    // if ((displaced_header = monitor->displaced_header()) == NULL) {
    //   // Recursive unlock. Mark the monitor unlocked by setting the object field to NULL.
    //   monitor->set_obj(NULL);
    // } else if (Atomic::cmpxchg(displaced_header, obj->mark_addr(), monitor) == monitor) {
    //   // We swapped the unlocked mark in displaced_header into the object's mark word.
    //   monitor->set_obj(NULL);
    // } else {
    //   // Slow path.
    //   InterpreterRuntime::monitorexit(THREAD, monitor);
    // }

    const Register tmp              = R13_ARG3;
    const Register object           = R14_ARG4;
    const Register displaced_header = R15_ARG5;
    const Register object_mark_addr = R16_ARG6;
    const Register current_header   = R17_ARG7;

    Label free_slot;
    Label slow_case;

    assert_different_registers(object, displaced_header, object_mark_addr, current_header);

    if (UseBiasedLocking) {
      unimplemented("Biased locking is not implemented");
      // The object address from the monitor is in object.
      ld_PPC(object, BasicObjectLock::obj_offset_in_bytes(), monitor);
      assert(oopDesc::mark_offset_in_bytes() == 0, "offset of _mark is not 0");
      biased_locking_exit(CCR0, object, displaced_header, free_slot);
    }

    // Test first if we are in the fast recursive case.
    ld(displaced_header, monitor, BasicObjectLock::lock_offset_in_bytes() + BasicLock::displaced_header_offset_in_bytes());

    // If the displaced header is zero, we have a recursive unlock.
    beqz(displaced_header, free_slot); // recursive unlock

    // } else if (Atomic::cmpxchg(displaced_header, obj->mark_addr(), monitor) == monitor) {
    //   // We swapped the unlocked mark in displaced_header into the object's mark word.
    //   monitor->set_obj(NULL);

    // If we still have a lightweight lock, unlock the object and be done.

    // The object address from the monitor is in object.
    if (!UseBiasedLocking) { ld_PPC(object, BasicObjectLock::obj_offset_in_bytes(), monitor); }
    addi(object_mark_addr, object, oopDesc::mark_offset_in_bytes());

    // We have the displaced header in displaced_header. If the lock is still
    // lightweight, it will contain the monitor address and we'll store the
    // displaced header back into the object's mark word.
    // CmpxchgX sets CCR0 to cmpX(current, monitor).
    cmpxchg_for_lock_release(/*current_value=*/current_header, /*compare_value=*/monitor,
                             /*exchange_value=*/displaced_header, /*where=*/object_mark_addr, tmp, &slow_case);
    j(free_slot);

    // } else {
    //   // Slow path.
    //   InterpreterRuntime::monitorexit(THREAD, monitor);

    // The lock has been converted into a heavy lock and hence
    // we need to get into the slow case.
    bind(slow_case);
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor, check_for_exceptions);
    // }

    Label done;
    j(done); // Monitor register may be overwritten! Runtime has already freed the slot.

    // Exchange worked, do monitor->set_obj(NULL);
    align(32, 12);
    bind(free_slot);
    sd(R0_ZERO, monitor, BasicObjectLock::obj_offset_in_bytes());
    bind(done);
  }
}

// Load compiled (i2c) or interpreter entry when calling from interpreted and
// do the call. Centralized so that all interpreter calls will do the same actions.
// If jvmti single stepping is on for a thread we must not call compiled code.
//
// Input:
//   - Rtarget_method: method to call
//   - Rret_addr:      return address
//   - 2 scratch regs
//
void InterpreterMacroAssembler::call_from_interpreter(Register Rtarget_method, Register Rret_addr,
                                                      Register Rscratch1, Register Rscratch2) {
  assert_different_registers(Rscratch1, Rscratch2, Rtarget_method, Rret_addr);
  // Assume we want to go compiled if available.
  const Register Rtarget_addr = Rscratch1;
  const Register Rinterp_only = Rscratch2;

  ld(Rtarget_addr, Rtarget_method, in_bytes(Method::from_interpreted_offset()));

  if (JvmtiExport::can_post_interpreter_events()) {
    lwu(Rinterp_only, R24_thread, in_bytes(JavaThread::interp_only_mode_offset()));

    // JVMTI events, such as single-stepping, are implemented partly by avoiding running
    // compiled code in threads for which the event is enabled. Check here for
    // interp_only_mode if these events CAN be enabled.
    Label done;
    verify_thread();
    beqz(Rinterp_only, done);
    ld(Rtarget_addr, Rtarget_method, in_bytes(Method::interpreter_entry_offset()));
    align(32, 12);
    bind(done);
  }

#ifdef ASSERT
  {
    Label Lok;
    bnez(Rtarget_addr, Lok);
    stop("null entry point");
    bind(Lok);
  }
#endif // ASSERT
  mv(R21_sender_SP, R2_SP);

  // Calc a precise SP for the call. The SP value we calculated in
  // generate_fixed_frame() is based on the max_stack() value, so we would waste stack space
  // if esp is not max. Also, the i2c adapter extends the stack space without restoring
  // our pre-calced value, so repeating calls via i2c would result in stack overflow.
  // Since esp already points to an empty slot, we just have to sub 1 additional slot
  // to meet the abi scratch requirements.
  // The max_stack pointer will get restored by means of the GR_Lmax_stack local in
  // the return entry of the interpreter.
  addi(R2_SP, R23_esp, Interpreter::stackElementSize);
  round_down_to(R2_SP, frame::alignment_in_bytes);

  mv_if_needed(R27_method, Rtarget_method);
  mv(R1_RA, Rret_addr);

  save_interpreter_state();
#ifdef ASSERT
  // TODO RISCV what are hell is going on with this field?
  // actual: 0x400191cdd0
  // expected: 0x400191cdc0
  //ld(Rscratch2, R8_FP, _ijava_state(top_frame_sp));
  //asm_assert_eq(R21_sender_SP, Rscratch2, "top_frame_sp incorrect", 0x951);
#endif

  jr(Rtarget_addr);
}

// Set the method data pointer for the current bcp.
void InterpreterMacroAssembler::set_method_data_pointer_for_bcp() {
  assert(ProfileInterpreter, "must be profiling interpreter");
  Label get_continue;
  ld_PPC(R28_mdx_PPC, in_bytes(Method::method_data_offset()), R27_method);
  test_method_data_pointer(get_continue);
  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::bcp_to_di), R27_method, R22_bcp);

  addi_PPC(R28_mdx_PPC, R28_mdx_PPC, in_bytes(MethodData::data_offset()));
  add_PPC(R28_mdx_PPC, R28_mdx_PPC, R3_RET_PPC);
  bind(get_continue);
}

// Test ImethodDataPtr. If it is null, continue at the specified label.
void InterpreterMacroAssembler::test_method_data_pointer(Label& zero_continue) {
  assert(ProfileInterpreter, "must be profiling interpreter");
  beqz(R29_mdx, zero_continue);
}

void InterpreterMacroAssembler::verify_method_data_pointer() {
  assert(ProfileInterpreter, "must be profiling interpreter");
#ifdef ASSERT
  Label verify_continue;
  test_method_data_pointer(verify_continue);

  // If the mdp is valid, it will point to a DataLayout header which is
  // consistent with the bcp. The converse is highly probable also.
  lhz_PPC(R5_scratch1, in_bytes(DataLayout::bci_offset()), R28_mdx_PPC);
  ld_PPC(R6_scratch2, in_bytes(Method::const_offset()), R27_method);
  addi_PPC(R5_scratch1, R5_scratch1, in_bytes(ConstMethod::codes_offset()));
  add_PPC(R5_scratch1, R6_scratch2, R6_scratch2);
  cmpd_PPC(CCR0, R5_scratch1, R22_bcp);
  beq_PPC(CCR0, verify_continue);

  call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::verify_mdp ), R27_method, R22_bcp, R28_mdx_PPC);

  bind(verify_continue);
#endif
}

void InterpreterMacroAssembler::test_invocation_counter_for_mdp(Register invocation_count,
                                                                Register method_counters,
                                                                Register Rscratch,
                                                                Label &profile_continue) {
  assert(ProfileInterpreter, "must be profiling interpreter");
  // Control will flow to "profile_continue" if the counter is less than the
  // limit or if we call profile_method().
  Label done;

  // If no method data exists, and the counter is high enough, make one.
  lwz_PPC(Rscratch, in_bytes(MethodCounters::interpreter_profile_limit_offset()), method_counters);

  cmpdi_PPC(CCR0, R28_mdx_PPC, 0);
  // Test to see if we should create a method data oop.
  cmpd_PPC(CCR1, Rscratch, invocation_count);
  bne_PPC(CCR0, done);
  bge_PPC(CCR1, profile_continue);

  // Build it now.
  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::profile_method));
  set_method_data_pointer_for_bcp();
  b_PPC(profile_continue);

  align(32, 12);
  bind(done);
}

void InterpreterMacroAssembler::test_backedge_count_for_osr(Register backedge_count, Register method_counters,
                                                            Register target_bcp, Register disp, Register Rtmp) {
  assert_different_registers(backedge_count, target_bcp, disp, Rtmp, R4_ARG2_PPC);
  assert(UseOnStackReplacement,"Must UseOnStackReplacement to test_backedge_count_for_osr");

  Label did_not_overflow;
  Label overflow_with_error;

  lwz_PPC(Rtmp, in_bytes(MethodCounters::interpreter_backward_branch_limit_offset()), method_counters);
  cmpw_PPC(CCR0, backedge_count, Rtmp);

  blt_PPC(CCR0, did_not_overflow);

  // When ProfileInterpreter is on, the backedge_count comes from the
  // methodDataOop, which value does not get reset on the call to
  // frequency_counter_overflow(). To avoid excessive calls to the overflow
  // routine while the method is being compiled, add a second test to make sure
  // the overflow function is called only once every overflow_frequency.
  if (ProfileInterpreter) {
    const int overflow_frequency = 1024;
    andi__PPC(Rtmp, backedge_count, overflow_frequency-1);
    bne_PPC(CCR0, did_not_overflow);
  }

  // Overflow in loop, pass branch bytecode.
  subf_PPC(R4_ARG2_PPC, disp, target_bcp); // Compute branch bytecode (previous bcp).
  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::frequency_counter_overflow), R4_ARG2_PPC, true);

  // Was an OSR adapter generated?
  cmpdi_PPC(CCR0, R3_RET_PPC, 0);
  beq_PPC(CCR0, overflow_with_error);

  // Has the nmethod been invalidated already?
  lbz_PPC(Rtmp, nmethod::state_offset(), R3_RET_PPC);
  cmpwi_PPC(CCR0, Rtmp, nmethod::in_use);
  bne_PPC(CCR0, overflow_with_error);

  // Migrate the interpreter frame off of the stack.
  // We can use all registers because we will not return to interpreter from this point.

  // Save nmethod.
  const Register osr_nmethod = R31;
  mr_PPC(osr_nmethod, R3_RET_PPC);
  set_top_ijava_frame_at_SP_as_last_Java_frame(R1_SP_PPC, R8_FP, R5_scratch1);
  call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::OSR_migration_begin), R24_thread);
  reset_last_Java_frame();
  // OSR buffer is in ARG1

  // Remove the interpreter frame.
  pop_java_frame();

  // Jump to the osr code.
  ld_PPC(R5_scratch1, nmethod::osr_entry_point_offset(), osr_nmethod);
  jr(R5_scratch1);

  align(32, 12);
  bind(overflow_with_error);
  bind(did_not_overflow);
}

// Store a value at some constant offset from the method data pointer.
void InterpreterMacroAssembler::set_mdp_data_at(int constant, Register value) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  std_PPC(value, constant, R28_mdx_PPC);
}

// Increment the value at some constant offset from the method data pointer.
void InterpreterMacroAssembler::increment_mdp_data_at(int constant,
                                                      Register counter_addr,
                                                      Register Rbumped_count,
                                                      bool decrement) {
  // Locate the counter at a fixed offset from the mdp:
  addi(counter_addr, R29_mdx, constant);
  increment_mdp_data_at(counter_addr, Rbumped_count, decrement);
}

// Increment the value at some non-fixed (reg + constant) offset from
// the method data pointer.
void InterpreterMacroAssembler::increment_mdp_data_at(Register reg,
                                                      int constant,
                                                      Register scratch,
                                                      Register Rbumped_count,
                                                      bool decrement) {
  // Add the constant to reg to get the offset.
  add_PPC(scratch, R28_mdx_PPC, reg);
  // Then calculate the counter address.
  addi_PPC(scratch, scratch, constant);
  increment_mdp_data_at(scratch, Rbumped_count, decrement);
}

void InterpreterMacroAssembler::increment_mdp_data_at(Register counter_addr,
                                                      Register Rbumped_count,
                                                      bool decrement) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  // Load the counter.
  ld(Rbumped_count, counter_addr, 0);

  if (decrement) {
    // Decrement the register. Set condition codes.
    addi(Rbumped_count, Rbumped_count, - DataLayout::counter_increment);
    // Store the decremented counter, if it is still negative.
    sd(Rbumped_count, counter_addr, 0);
    // Note: add/sub overflow check are not ported, since 64 bit
    // calculation should never overflow.
  } else {
    // Increment the register. Set carry flag.
    addi(Rbumped_count, Rbumped_count, DataLayout::counter_increment);
    // Store the incremented counter.
    sd(Rbumped_count, counter_addr, 0);
  }
}

// Set a flag value at the current method data pointer position.
void InterpreterMacroAssembler::set_mdp_flag_at(int flag_constant,
                                                Register scratch) {
  assert(ProfileInterpreter, "must be profiling interpreter");
  // Load the data header.
  lbz_PPC(scratch, in_bytes(DataLayout::flags_offset()), R28_mdx_PPC);
  // Set the flag.
  ori_PPC(scratch, scratch, flag_constant);
  // Store the modified header.
  stb_PPC(scratch, in_bytes(DataLayout::flags_offset()), R28_mdx_PPC);
}

// Test the location at some offset from the method data pointer.
// If it is not equal to value, branch to the not_equal_continue Label.
void InterpreterMacroAssembler::test_mdp_data_at(int offset,
                                                 Register value,
                                                 Label& not_equal_continue,
                                                 Register test_out) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  ld_PPC(test_out, offset, R28_mdx_PPC);
  cmpd_PPC(CCR0,  value, test_out);
  bne_PPC(CCR0, not_equal_continue);
}

// Update the method data pointer by the displacement located at some fixed
// offset from the method data pointer.
void InterpreterMacroAssembler::update_mdp_by_offset(int offset_of_disp,
                                                     Register scratch) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  ld_PPC(scratch, offset_of_disp, R28_mdx_PPC);
  add_PPC(R28_mdx_PPC, scratch, R28_mdx_PPC);
}

// Update the method data pointer by the displacement located at the
// offset (reg + offset_of_disp).
void InterpreterMacroAssembler::update_mdp_by_offset(Register reg,
                                                     int offset_of_disp,
                                                     Register scratch) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  add_PPC(scratch, reg, R28_mdx_PPC);
  ld_PPC(scratch, offset_of_disp, scratch);
  add_PPC(R28_mdx_PPC, scratch, R28_mdx_PPC);
}

// Update the method data pointer by a simple constant displacement.
void InterpreterMacroAssembler::update_mdp_by_constant(int constant) {
  assert(ProfileInterpreter, "must be profiling interpreter");
  addi(R29_mdx, R29_mdx, constant);
}

// Update the method data pointer for a _ret bytecode whose target
// was not among our cached targets.
void InterpreterMacroAssembler::update_mdp_for_ret(TosState state,
                                                   Register return_bci) {
  assert(ProfileInterpreter, "must be profiling interpreter");

  push(state);
  assert(return_bci->is_nonvolatile(), "need to protect return_bci");
  call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::update_mdp_for_ret), return_bci);
  pop(state);
}

// Increments the backedge counter.
// Returns backedge counter + invocation counter in Rdst.
void InterpreterMacroAssembler::increment_backedge_counter(const Register Rcounters, const Register Rdst,
                                                           const Register Rtmp1, Register Rscratch) {
  assert(UseCompiler, "incrementing must be useful");
  assert_different_registers(Rdst, Rtmp1);
  const Register invocation_counter = Rtmp1;
  const Register counter = Rdst;
  // TODO: RISCV port: assert(4 == InvocationCounter::sz_counter(), "unexpected field size.");

  // Load backedge counter.
  lwz_PPC(counter, in_bytes(MethodCounters::backedge_counter_offset()) +
               in_bytes(InvocationCounter::counter_offset()), Rcounters);
  // Load invocation counter.
  lwz_PPC(invocation_counter, in_bytes(MethodCounters::invocation_counter_offset()) +
                          in_bytes(InvocationCounter::counter_offset()), Rcounters);

  // Add the delta to the backedge counter.
  addi_PPC(counter, counter, InvocationCounter::count_increment);

  // Mask the invocation counter.
  andi_PPC(invocation_counter, invocation_counter, InvocationCounter::count_mask_value);

  // Store new counter value.
  stw_PPC(counter, in_bytes(MethodCounters::backedge_counter_offset()) +
               in_bytes(InvocationCounter::counter_offset()), Rcounters);
  // Return invocation counter + backedge counter.
  add_PPC(counter, counter, invocation_counter);
}

// Count a taken branch in the bytecodes.
void InterpreterMacroAssembler::profile_taken_branch(Register scratch, Register bumped_count) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // We are taking a branch. Increment the taken count.
    increment_mdp_data_at(in_bytes(JumpData::taken_offset()), scratch, bumped_count);

    // The method data pointer needs to be updated to reflect the new target.
    update_mdp_by_offset(in_bytes(JumpData::displacement_offset()), scratch);
    bind (profile_continue);
  }
}

// Count a not-taken branch in the bytecodes.
void InterpreterMacroAssembler::profile_not_taken_branch(Register scratch1, Register scratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // We are taking a branch. Increment the not taken count.
    increment_mdp_data_at(in_bytes(BranchData::not_taken_offset()), scratch1, scratch2);

    // The method data pointer needs to be updated to correspond to the
    // next bytecode.
    update_mdp_by_constant(in_bytes(BranchData::branch_data_size()));
    bind (profile_continue);
  }
}

// Count a non-virtual call in the bytecodes.
void InterpreterMacroAssembler::profile_call(Register scratch1, Register scratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // We are making a call. Increment the count.
    increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);

    // The method data pointer needs to be updated to reflect the new target.
    update_mdp_by_constant(in_bytes(CounterData::counter_data_size()));
    bind (profile_continue);
  }
}

// Count a final call in the bytecodes.
void InterpreterMacroAssembler::profile_final_call(Register scratch1, Register scratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // We are making a call. Increment the count.
    increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);

    // The method data pointer needs to be updated to reflect the new target.
    update_mdp_by_constant(in_bytes(VirtualCallData::virtual_call_data_size()));
    bind (profile_continue);
  }
}

// Count a virtual call in the bytecodes.
void InterpreterMacroAssembler::profile_virtual_call(Register Rreceiver,
                                                     Register Rscratch1,
                                                     Register Rscratch2,
                                                     bool receiver_can_be_null) {
  if (!ProfileInterpreter) { return; }
  Label profile_continue;

  // If no method data exists, go to profile_continue.
  test_method_data_pointer(profile_continue);

  Label skip_receiver_profile;
  if (receiver_can_be_null) {
    Label not_null;
    cmpdi_PPC(CCR0, Rreceiver, 0);
    bne_PPC(CCR0, not_null);
    // We are making a call. Increment the count for null receiver.
    increment_mdp_data_at(in_bytes(CounterData::count_offset()), Rscratch1, Rscratch2);
    b_PPC(skip_receiver_profile);
    bind(not_null);
  }

  // Record the receiver type.
  record_klass_in_profile(Rreceiver, Rscratch1, Rscratch2, true);
  bind(skip_receiver_profile);

  // The method data pointer needs to be updated to reflect the new target.
  update_mdp_by_constant(in_bytes(VirtualCallData::virtual_call_data_size()));
  bind (profile_continue);
}

void InterpreterMacroAssembler::profile_typecheck(Register Rklass, Register Rscratch1, Register Rscratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    int mdp_delta = in_bytes(BitData::bit_data_size());
    if (TypeProfileCasts) {
      mdp_delta = in_bytes(VirtualCallData::virtual_call_data_size());

      // Record the object type.
      record_klass_in_profile(Rklass, Rscratch1, Rscratch2, false);
    }

    // The method data pointer needs to be updated.
    update_mdp_by_constant(mdp_delta);

    bind (profile_continue);
  }
}

void InterpreterMacroAssembler::profile_typecheck_failed(Register Rscratch1, Register Rscratch2) {
  if (ProfileInterpreter && TypeProfileCasts) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    int count_offset = in_bytes(CounterData::count_offset());
    // Back up the address, since we have already bumped the mdp.
    count_offset -= in_bytes(VirtualCallData::virtual_call_data_size());

    // *Decrement* the counter. We expect to see zero or small negatives.
    increment_mdp_data_at(count_offset, Rscratch1, Rscratch2, true);

    bind (profile_continue);
  }
}

// Count a ret in the bytecodes.
void InterpreterMacroAssembler::profile_ret(TosState state, Register return_bci,
                                            Register scratch1, Register scratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;
    uint row;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // Update the total ret count.
    increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2 );

    for (row = 0; row < RetData::row_limit(); row++) {
      Label next_test;

      // See if return_bci is equal to bci[n]:
      test_mdp_data_at(in_bytes(RetData::bci_offset(row)), return_bci, next_test, scratch1);

      // return_bci is equal to bci[n]. Increment the count.
      increment_mdp_data_at(in_bytes(RetData::bci_count_offset(row)), scratch1, scratch2);

      // The method data pointer needs to be updated to reflect the new target.
      update_mdp_by_offset(in_bytes(RetData::bci_displacement_offset(row)), scratch1);
      b_PPC(profile_continue);
      bind(next_test);
    }

    update_mdp_for_ret(state, return_bci);

    bind (profile_continue);
  }
}

// Count the default case of a switch construct.
void InterpreterMacroAssembler::profile_switch_default(Register scratch1,  Register scratch2) {
  if (ProfileInterpreter) {
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // Update the default case count
    increment_mdp_data_at(in_bytes(MultiBranchData::default_count_offset()),
                          scratch1, scratch2);

    // The method data pointer needs to be updated.
    update_mdp_by_offset(in_bytes(MultiBranchData::default_displacement_offset()),
                         scratch1);

    bind (profile_continue);
  }
}

// Count the index'th case of a switch construct.
void InterpreterMacroAssembler::profile_switch_case(Register index,
                                                    Register scratch1,
                                                    Register scratch2,
                                                    Register scratch3) {
  if (ProfileInterpreter) {
    assert_different_registers(index, scratch1, scratch2, scratch3);
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    // Build the base (index * per_case_size_in_bytes()) + case_array_offset_in_bytes().
    li_PPC(scratch3, in_bytes(MultiBranchData::case_array_offset()));

    assert (in_bytes(MultiBranchData::per_case_size()) == 16, "so that shladd works");
    sldi_PPC(scratch1, index, exact_log2(in_bytes(MultiBranchData::per_case_size())));
    add_PPC(scratch1, scratch1, scratch3);

    // Update the case count.
    increment_mdp_data_at(scratch1, in_bytes(MultiBranchData::relative_count_offset()), scratch2, scratch3);

    // The method data pointer needs to be updated.
    update_mdp_by_offset(scratch1, in_bytes(MultiBranchData::relative_displacement_offset()), scratch2);

    bind (profile_continue);
  }
}

void InterpreterMacroAssembler::profile_null_seen(Register Rscratch1, Register Rscratch2) {
  if (ProfileInterpreter) {
    assert_different_registers(Rscratch1, Rscratch2);
    Label profile_continue;

    // If no method data exists, go to profile_continue.
    test_method_data_pointer(profile_continue);

    set_mdp_flag_at(BitData::null_seen_byte_constant(), Rscratch1);

    // The method data pointer needs to be updated.
    int mdp_delta = in_bytes(BitData::bit_data_size());
    if (TypeProfileCasts) {
      mdp_delta = in_bytes(VirtualCallData::virtual_call_data_size());
    }
    update_mdp_by_constant(mdp_delta);

    bind (profile_continue);
  }
}

void InterpreterMacroAssembler::record_klass_in_profile(Register Rreceiver,
                                                        Register Rscratch1, Register Rscratch2,
                                                        bool is_virtual_call) {
  assert(ProfileInterpreter, "must be profiling");
  assert_different_registers(Rreceiver, Rscratch1, Rscratch2);

  Label done;
  record_klass_in_profile_helper(Rreceiver, Rscratch1, Rscratch2, 0, done, is_virtual_call);
  bind (done);
}

void InterpreterMacroAssembler::record_klass_in_profile_helper(
                                        Register receiver, Register scratch1, Register scratch2,
                                        int start_row, Label& done, bool is_virtual_call) {
  if (TypeProfileWidth == 0) {
    if (is_virtual_call) {
      increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);
    }
    return;
  }

  int last_row = VirtualCallData::row_limit() - 1;
  assert(start_row <= last_row, "must be work left to do");
  // Test this row for both the receiver and for null.
  // Take any of three different outcomes:
  //   1. found receiver => increment count and goto done
  //   2. found null => keep looking for case 1, maybe allocate this cell
  //   3. found something else => keep looking for cases 1 and 2
  // Case 3 is handled by a recursive call.
  for (int row = start_row; row <= last_row; row++) {
    Label next_test;
    bool test_for_null_also = (row == start_row);

    // See if the receiver is receiver[n].
    int recvr_offset = in_bytes(VirtualCallData::receiver_offset(row));
    test_mdp_data_at(recvr_offset, receiver, next_test, scratch1);
    // delayed()->tst(scratch);

    // The receiver is receiver[n]. Increment count[n].
    int count_offset = in_bytes(VirtualCallData::receiver_count_offset(row));
    increment_mdp_data_at(count_offset, scratch1, scratch2);
    b_PPC(done);
    bind(next_test);

    if (test_for_null_also) {
      Label found_null;
      // Failed the equality check on receiver[n]... Test for null.
      if (start_row == last_row) {
        // The only thing left to do is handle the null case.
        if (is_virtual_call) {
          // Scratch1 contains test_out from test_mdp_data_at.
          cmpdi_PPC(CCR0, scratch1, 0);
          beq_PPC(CCR0, found_null);
          // Receiver did not match any saved receiver and there is no empty row for it.
          // Increment total counter to indicate polymorphic case.
          increment_mdp_data_at(in_bytes(CounterData::count_offset()), scratch1, scratch2);
          b_PPC(done);
          bind(found_null);
        } else {
          cmpdi_PPC(CCR0, scratch1, 0);
          bne_PPC(CCR0, done);
        }
        break;
      }
      // Since null is rare, make it be the branch-taken case.
      cmpdi_PPC(CCR0, scratch1, 0);
      beq_PPC(CCR0, found_null);

      // Put all the "Case 3" tests here.
      record_klass_in_profile_helper(receiver, scratch1, scratch2, start_row + 1, done, is_virtual_call);

      // Found a null. Keep searching for a matching receiver,
      // but remember that this is an empty (unused) slot.
      bind(found_null);
    }
  }

  // In the fall-through case, we found no matching receiver, but we
  // observed the receiver[start_row] is NULL.

  // Fill in the receiver field and increment the count.
  int recvr_offset = in_bytes(VirtualCallData::receiver_offset(start_row));
  set_mdp_data_at(recvr_offset, receiver);
  int count_offset = in_bytes(VirtualCallData::receiver_count_offset(start_row));
  li_PPC(scratch1, DataLayout::counter_increment);
  set_mdp_data_at(count_offset, scratch1);
  if (start_row > 0) {
    b_PPC(done);
  }
}

// Argument and return type profilig.
// kills: tmp, tmp2, R0, CR0, CR1
void InterpreterMacroAssembler::profile_obj_type(Register obj, Register mdo_addr_base,
                                                 RegisterOrConstant mdo_addr_offs,
                                                 Register tmp, Register tmp2) {
  Label do_nothing, do_update;

  // tmp2 = obj is allowed
  assert_different_registers(obj, mdo_addr_base, tmp, R0);
  assert_different_registers(tmp2, mdo_addr_base, tmp, R0);
  const Register klass = tmp2;

  verify_oop(obj);

  ld_PPC(tmp, mdo_addr_offs, mdo_addr_base);

  // Set null_seen if obj is 0.
  cmpdi_PPC(CCR0, obj, 0);
  ori_PPC(R0, tmp, TypeEntries::null_seen);
  beq_PPC(CCR0, do_update);

  load_klass(klass, obj);

  clrrdi_PPC(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
  // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
  cmpd_PPC(CCR1, R0, klass);
  // Klass seen before, nothing to do (regardless of unknown bit).
  //beq(CCR1, do_nothing);

  andi__PPC(R0, klass, TypeEntries::type_unknown);
  // Already unknown. Nothing to do anymore.
  //bne(CCR0, do_nothing);
  crorc_PPC(CCR0, Assembler::equal, CCR1, Assembler::equal); // cr0 eq = cr1 eq or cr0 ne
  beq_PPC(CCR0, do_nothing);

  clrrdi__PPC(R0, tmp, exact_log2(-TypeEntries::type_mask));
  orr_PPC(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp & type_mask)==0).
  beq_PPC(CCR0, do_update); // First time here. Set profile type.

  // Different than before. Cannot keep accurate profile.
  ori_PPC(R0, tmp, TypeEntries::type_unknown);

  bind(do_update);
  // update profile
  std_PPC(R0, mdo_addr_offs, mdo_addr_base);

  align(32, 12);
  bind(do_nothing);
}

void InterpreterMacroAssembler::profile_arguments_type(Register callee,
                                                       Register tmp1, Register tmp2,
                                                       bool is_virtual) {
  if (!ProfileInterpreter) {
    return;
  }

  assert_different_registers(callee, tmp1, tmp2, R28_mdx_PPC);

  if (MethodData::profile_arguments() || MethodData::profile_return()) {
    Label profile_continue;

    test_method_data_pointer(profile_continue);

    int off_to_start = is_virtual ?
      in_bytes(VirtualCallData::virtual_call_data_size()) : in_bytes(CounterData::counter_data_size());

    lbz_PPC(tmp1, in_bytes(DataLayout::tag_offset()) - off_to_start, R28_mdx_PPC);
    cmpwi_PPC(CCR0, tmp1, is_virtual ? DataLayout::virtual_call_type_data_tag : DataLayout::call_type_data_tag);
    bne_PPC(CCR0, profile_continue);

    if (MethodData::profile_arguments()) {
      Label done;
      int off_to_args = in_bytes(TypeEntriesAtCall::args_data_offset());
      add_PPC(R28_mdx_PPC, off_to_args, R28_mdx_PPC);

      for (int i = 0; i < TypeProfileArgsLimit; i++) {
        if (i > 0 || MethodData::profile_return()) {
          // If return value type is profiled we may have no argument to profile.
          ld_PPC(tmp1, in_bytes(TypeEntriesAtCall::cell_count_offset())-off_to_args, R28_mdx_PPC);
          cmpdi_PPC(CCR0, tmp1, (i+1)*TypeStackSlotEntries::per_arg_count());
          addi_PPC(tmp1, tmp1, -i*TypeStackSlotEntries::per_arg_count());
          blt_PPC(CCR0, done);
        }
        ld_PPC(tmp1, in_bytes(Method::const_offset()), callee);
        lhz_PPC(tmp1, in_bytes(ConstMethod::size_of_parameters_offset()), tmp1);
        // Stack offset o (zero based) from the start of the argument
        // list, for n arguments translates into offset n - o - 1 from
        // the end of the argument list. But there's an extra slot at
        // the top of the stack. So the offset is n - o from Lesp.
        ld_PPC(tmp2, in_bytes(TypeEntriesAtCall::stack_slot_offset(i))-off_to_args, R28_mdx_PPC);
        subf_PPC(tmp1, tmp2, tmp1);

        sldi_PPC(tmp1, tmp1, Interpreter::logStackElementSize);
        ldx_PPC(tmp1, tmp1, R23_esp);

        profile_obj_type(tmp1, R28_mdx_PPC, in_bytes(TypeEntriesAtCall::argument_type_offset(i))-off_to_args, tmp2, tmp1);

        int to_add = in_bytes(TypeStackSlotEntries::per_arg_size());
        addi_PPC(R28_mdx_PPC, R28_mdx_PPC, to_add);
        off_to_args += to_add;
      }

      if (MethodData::profile_return()) {
        ld_PPC(tmp1, in_bytes(TypeEntriesAtCall::cell_count_offset())-off_to_args, R28_mdx_PPC);
        addi_PPC(tmp1, tmp1, -TypeProfileArgsLimit*TypeStackSlotEntries::per_arg_count());
      }

      bind(done);

      if (MethodData::profile_return()) {
        // We're right after the type profile for the last
        // argument. tmp1 is the number of cells left in the
        // CallTypeData/VirtualCallTypeData to reach its end. Non null
        // if there's a return to profile.
        assert(ReturnTypeEntry::static_cell_count() < TypeStackSlotEntries::per_arg_count(),
               "can't move past ret type");
        sldi_PPC(tmp1, tmp1, exact_log2(DataLayout::cell_size));
        add_PPC(R28_mdx_PPC, tmp1, R28_mdx_PPC);
      }
    } else {
      assert(MethodData::profile_return(), "either profile call args or call ret");
      update_mdp_by_constant(in_bytes(TypeEntriesAtCall::return_only_size()));
    }

    // Mdp points right after the end of the
    // CallTypeData/VirtualCallTypeData, right after the cells for the
    // return value type if there's one.
    align(32, 12);
    bind(profile_continue);
  }
}

void InterpreterMacroAssembler::profile_return_type(Register ret, Register tmp1, Register tmp2) {
  assert_different_registers(ret, tmp1, tmp2);
  if (ProfileInterpreter && MethodData::profile_return()) {
    Label profile_continue;

    test_method_data_pointer(profile_continue);

    if (MethodData::profile_return_jsr292_only()) {
      // If we don't profile all invoke bytecodes we must make sure
      // it's a bytecode we indeed profile. We can't go back to the
      // begining of the ProfileData we intend to update to check its
      // type because we're right after it and we don't known its
      // length.
      lbz_PPC(tmp1, 0, R22_bcp);
      lbz_PPC(tmp2, Method::intrinsic_id_offset_in_bytes(), R27_method);
      cmpwi_PPC(CCR0, tmp1, Bytecodes::_invokedynamic);
      cmpwi_PPC(CCR1, tmp1, Bytecodes::_invokehandle);
      cror_PPC(CCR0, Assembler::equal, CCR1, Assembler::equal);
      cmpwi_PPC(CCR1, tmp2, vmIntrinsics::_compiledLambdaForm);
      cror_PPC(CCR0, Assembler::equal, CCR1, Assembler::equal);
      bne_PPC(CCR0, profile_continue);
    }

    profile_obj_type(ret, R28_mdx_PPC, -in_bytes(ReturnTypeEntry::size()), tmp1, tmp2);

    align(32, 12);
    bind(profile_continue);
  }
}

void InterpreterMacroAssembler::profile_parameters_type(Register tmp1, Register tmp2,
                                                        Register tmp3, Register tmp4) {
  if (ProfileInterpreter && MethodData::profile_parameters()) {
    Label profile_continue, done;

    test_method_data_pointer(profile_continue);

    // Load the offset of the area within the MDO used for
    // parameters. If it's negative we're not profiling any parameters.
    lwz_PPC(tmp1, in_bytes(MethodData::parameters_type_data_di_offset()) - in_bytes(MethodData::data_offset()), R28_mdx_PPC);
    cmpwi_PPC(CCR0, tmp1, 0);
    blt_PPC(CCR0, profile_continue);

    // Compute a pointer to the area for parameters from the offset
    // and move the pointer to the slot for the last
    // parameters. Collect profiling from last parameter down.
    // mdo start + parameters offset + array length - 1

    // Pointer to the parameter area in the MDO.
    const Register mdp = tmp1;
    add_PPC(mdp, tmp1, R28_mdx_PPC);

    // Offset of the current profile entry to update.
    const Register entry_offset = tmp2;
    // entry_offset = array len in number of cells
    ld_PPC(entry_offset, in_bytes(ArrayData::array_len_offset()), mdp);

    int off_base = in_bytes(ParametersTypeData::stack_slot_offset(0));
    assert(off_base % DataLayout::cell_size == 0, "should be a number of cells");

    // entry_offset (number of cells)  = array len - size of 1 entry + offset of the stack slot field
    addi_PPC(entry_offset, entry_offset, -TypeStackSlotEntries::per_arg_count() + (off_base / DataLayout::cell_size));
    // entry_offset in bytes
    sldi_PPC(entry_offset, entry_offset, exact_log2(DataLayout::cell_size));

    Label loop;
    align(32, 12);
    bind(loop);

    // Load offset on the stack from the slot for this parameter.
    ld_PPC(tmp3, entry_offset, mdp);
    sldi_PPC(tmp3, tmp3, Interpreter::logStackElementSize);
    neg_PPC(tmp3, tmp3);
    // Read the parameter from the local area.
    ldx_PPC(tmp3, tmp3, R26_locals);

    // Make entry_offset now point to the type field for this parameter.
    int type_base = in_bytes(ParametersTypeData::type_offset(0));
    assert(type_base > off_base, "unexpected");
    addi_PPC(entry_offset, entry_offset, type_base - off_base);

    // Profile the parameter.
    profile_obj_type(tmp3, mdp, entry_offset, tmp4, tmp3);

    // Go to next parameter.
    int delta = TypeStackSlotEntries::per_arg_count() * DataLayout::cell_size + (type_base - off_base);
    cmpdi_PPC(CCR0, entry_offset, off_base + delta);
    addi_PPC(entry_offset, entry_offset, -delta);
    bge_PPC(CCR0, loop);

    align(32, 12);
    bind(profile_continue);
  }
}

// Add a InterpMonitorElem to stack (see frame_sparc.hpp).
void InterpreterMacroAssembler::add_monitor_to_stack(bool stack_is_empty, Register Rtemp1, Register Rtemp2) {

  // Very-local scratch registers.
  const Register esp  = Rtemp1;
  const Register slot = Rtemp2;

  // Extracted monitor_size.
  int monitor_size = frame::interpreter_frame_monitor_size_in_bytes();
  assert(Assembler::is_aligned((unsigned int)monitor_size,
                               (unsigned int)frame::alignment_in_bytes),
         "size of a monitor must respect alignment of SP");

  resize_frame(-monitor_size, Rtemp1); // Allocate space for new monitor
  sd(R2_SP, R8_FP, _ijava_state(top_frame_sp));

  // Shuffle expression stack down. Recall that stack_base points
  // just above the new expression stack bottom. Old_tos and new_tos
  // are used to scan thru the old and new expression stacks.
  if (!stack_is_empty) {
    Label copy_slot, copy_slot_finished;
    const Register n_slots = slot;

    addi(esp, R23_esp, Interpreter::stackElementSize); // Point to first element (pre-pushed stack).
    sub(n_slots, R18_monitor, esp);
    srli(n_slots, n_slots, LogBytesPerWord); // Compute number of slots to copy.
    assert(LogBytesPerWord == 3, "conflicts assembler instructions");
    beqz(n_slots, copy_slot_finished); // Nothing to copy.

    mv(R29_TMP4, n_slots);

    // loop
    bind(copy_slot);
    ld(slot, esp, 0); // Move expression stack down.
    sd(slot, esp, -monitor_size); // distance = monitor_size
    addi(esp, esp, BytesPerWord);
    addi(R29_TMP4, R29_TMP4, -1);
    bnez(R29_TMP4, copy_slot);

    bind(copy_slot_finished);
  }

  addi(R23_esp, R23_esp, -monitor_size);
  addi(R18_monitor, R18_monitor, -monitor_size);

  // Restart interpreter
}

// ============================================================================
// Java locals access

// Load a local variable at index in Rindex into register Rdst_value.
// Also puts address of local into Rdst_address as a service.
// Kills:
//   - Rdst_value
//   - Rdst_address
void InterpreterMacroAssembler::load_local_int(Register Rdst_value, Register Rdst_address, Register Rindex) {
  slli(Rdst_address, Rindex, Interpreter::logStackElementSize);
  sub(Rdst_address, R26_locals, Rdst_address);
  lw(Rdst_value, Rdst_address, 0);
}

// Load a local variable at index in Rindex into register Rdst_value.
// Also puts address of local into Rdst_address as a service.
// Kills:
//   - Rdst_value
//   - Rdst_address
void InterpreterMacroAssembler::load_local_long(Register Rdst_value, Register Rdst_address, Register Rindex) {
  slli(Rdst_address, Rindex, Interpreter::logStackElementSize);
  sub(Rdst_address, R26_locals, Rdst_address);
  ld(Rdst_value, Rdst_address, -8);
}

// Load a local variable at index in Rindex into register Rdst_value.
// Also puts address of local into Rdst_address as a service.
// Input:
//   - Rindex:      slot nr of local variable
// Kills:
//   - Rdst_value
//   - Rdst_address
void InterpreterMacroAssembler::load_local_ptr(Register Rdst_value,
                                               Register Rdst_address,
                                               Register Rindex) {
  slli(Rdst_address, Rindex, Interpreter::logStackElementSize);
  sub(Rdst_address, R26_locals, Rdst_address);
  ld(Rdst_value, Rdst_address, 0);
}

// Load a local variable at index in Rindex into register Rdst_value.
// Also puts address of local into Rdst_address as a service.
// Kills:
//   - Rdst_value
//   - Rdst_address
void InterpreterMacroAssembler::load_local_float(FloatRegister Rdst_value,
                                                 Register Rdst_address,
                                                 Register Rindex) {
  slli(Rdst_address, Rindex, Interpreter::logStackElementSize);
  sub(Rdst_address, R26_locals, Rdst_address);
  flw(Rdst_value, Rdst_address, 0);
}

// Load a local variable at index in Rindex into register Rdst_value.
// Also puts address of local into Rdst_address as a service.
// Kills:
//   - Rdst_value
//   - Rdst_address
void InterpreterMacroAssembler::load_local_double(FloatRegister Rdst_value,
                                                  Register Rdst_address,
                                                  Register Rindex) {
  slli(Rdst_address, Rindex, Interpreter::logStackElementSize);
  sub(Rdst_address, R26_locals, Rdst_address);
  fld(Rdst_value, Rdst_address, -8);
}

// Store an int value at local variable slot Rindex.
// Kills:
//   - Rindex
void InterpreterMacroAssembler::store_local_int(Register Rvalue, Register Rindex) {
  slli(Rindex, Rindex, Interpreter::logStackElementSize);
  sub(Rindex, R26_locals, Rindex);
  sw(Rvalue, Rindex, 0);
}

// Store a long value at local variable slot Rindex.
// Kills:
//   - Rindex
void InterpreterMacroAssembler::store_local_long(Register Rvalue, Register Rindex) {
  slli(Rindex, Rindex, Interpreter::logStackElementSize);
  sub(Rindex, R26_locals, Rindex);
  sd(Rvalue, Rindex, -8);
}

// Store an oop value at local variable slot Rindex.
// Kills:
//   - Rindex
void InterpreterMacroAssembler::store_local_ptr(Register Rvalue, Register Rindex) {
  slli(Rindex, Rindex, Interpreter::logStackElementSize);
  sub(Rindex, R26_locals, Rindex);
  sd(Rvalue, Rindex, 0);
}

// Store a float value at local variable slot Rindex.
// Kills:
//   - Rindex
void InterpreterMacroAssembler::store_local_float(FloatRegister Rvalue, Register Rindex) {
  slli(Rindex, Rindex, Interpreter::logStackElementSize);
  sub(Rindex, R26_locals, Rindex);
  fsw(Rvalue, Rindex, 0);
}

// Store a double value at local variable slot Rindex.
// Kills:
//   - Rindex
void InterpreterMacroAssembler::store_local_double(FloatRegister Rvalue, Register Rindex) {
  slli(Rindex, Rindex, Interpreter::logStackElementSize);
  sub(Rindex, R26_locals, Rindex);
  fsd(Rvalue, Rindex, -8);
}

// Read pending exception from thread and jump to interpreter.
// Throw exception entry if one if pending. Fall through otherwise.
void InterpreterMacroAssembler::check_and_forward_exception(Register Rscratch1, Register Rscratch2) {
  assert_different_registers(Rscratch1, Rscratch2, R3);
  Register Rexception = Rscratch1;
  Register Rtmp       = Rscratch2;
  Label Ldone;
  // Get pending exception oop.
  ld_PPC(Rexception, thread_PPC(pending_exception));
  cmpdi_PPC(CCR0, Rexception, 0);
  beq_PPC(CCR0, Ldone);
  li_PPC(Rtmp, 0);
  mv_if_needed(R3, Rexception);
  std_PPC(Rtmp, thread_PPC(pending_exception)); // Clear exception in thread
  if (Interpreter::rethrow_exception_entry() != NULL) {
    // Already got entry address.
    load_dispatch_table(Rtmp, (address*)Interpreter::rethrow_exception_entry());
  } else {
    // Dynamically load entry address.
    int simm16_rest = load_const_optimized(Rtmp, &Interpreter::_rethrow_exception_entry, R0, true);
    ld_PPC(Rtmp, simm16_rest, Rtmp);
  }
  mtctr_PPC(Rtmp);
  save_interpreter_state();
  bctr_PPC();

  align(32, 12);
  bind(Ldone);
}

void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point, bool check_exceptions) {
  save_interpreter_state();

  MacroAssembler::call_VM(oop_result, entry_point, false);

  restore_interpreter_state(/*bcp_and_mdx_only*/ true);

  check_and_handle_popframe(R5_scratch1, R6_scratch2);

  // FIXME_RISCV begin
  // check_and_handle_earlyret(R5_scratch1);
  // Now check exceptions manually.
  //  if (check_exceptions) {
  //    check_and_forward_exception(R5_scratch1, R6_scratch2);
  //  }
  // FIXME_RISCV end
}

void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point,
                                        Register arg_1, bool check_exceptions) {
  // ARG0 is reserved for the thread.
  mv_if_needed(R11_ARG1, arg_1);
  call_VM(oop_result, entry_point, check_exceptions);
}

void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point,
                                        Register arg_1, Register arg_2,
                                        bool check_exceptions) {
  // ARG1 is reserved for the thread.
  mv_if_needed(R11_ARG1, arg_1);
  assert(arg_2 != R11_ARG1, "smashed argument");
  mv_if_needed(R12_ARG2, arg_2);
  call_VM(oop_result, entry_point, check_exceptions);
}

void InterpreterMacroAssembler::call_VM(Register oop_result, address entry_point,
                                        Register arg_1, Register arg_2, Register arg_3,
                                        bool check_exceptions) {
  // ARG0 is reserved for the thread.
  mv_if_needed(R11_ARG1, arg_1);
  assert(arg_2 != R11_ARG1, "smashed argument");
  mv_if_needed(R12_ARG2, arg_2);
  assert(arg_3 != R12_ARG2 && arg_3 != R11_ARG1, "smashed argument");
  mv_if_needed(R13_ARG3, arg_3);
  call_VM(oop_result, entry_point, check_exceptions);
}

void InterpreterMacroAssembler::save_interpreter_state() {
  sd(R23_esp, R8_FP, _ijava_state(esp));
  sd(R22_bcp, R8_FP, _ijava_state(bcp));
  sd(R18_monitor, R8_FP, _ijava_state(monitors));
  if (ProfileInterpreter) { sd(R29_mdx, R8_FP, _ijava_state(mdx)); }
  // Other entries should be unchanged.
}

void InterpreterMacroAssembler::restore_interpreter_state(bool bcp_and_mdx_only) {
  ld(R22_bcp, R8_FP, _ijava_state(bcp)); // Changed by VM code (exception).
  if (ProfileInterpreter) { ld(R29_mdx, R8_FP, _ijava_state(mdx)); } // Changed by VM code.
  if (!bcp_and_mdx_only) {
    // Following ones are Metadata.
    ld(R27_method, R8_FP, _ijava_state(method));
    ld(R9_constPoolCache, R8_FP, _ijava_state(cpoolCache));
    // Following ones are stack addresses and don't require reload.
    ld(R23_esp, R8_FP, _ijava_state(esp));
    ld(R26_locals, R8_FP, _ijava_state(locals));
    ld(R18_monitor, R8_FP, _ijava_state(monitors));

  }
#ifdef ASSERT
  {
    Label Lok;
    sub(R5_scratch1, R8_FP, R2_SP);
    slti(R5_scratch1, R5_scratch1, frame::frame_header_size);
    beqz(R5_scratch1, Lok); // ok if frame_size >= header_size + ijava_state_size
    stop("frame too small (restore istate)", 0x5432);
    bind(Lok);
  }
  {
    Label Lok;
    ld(R5_scratch1, R8_FP, _ijava_state(ijava_reserved));
    li(R6_scratch2, 0x5afe);
    beq(R5_scratch1, R6_scratch2, Lok);
    stop("frame corrupted (restore istate)", 0x5afe);
    bind(Lok);
  }
#endif
}

void InterpreterMacroAssembler::get_method_counters(Register method,
                                                    Register Rcounters,
                                                    Label& skip) {
  BLOCK_COMMENT("Load and ev. allocate counter object {");
  Label has_counters;
  ld_PPC(Rcounters, in_bytes(Method::method_counters_offset()), method);
  cmpdi_PPC(CCR0, Rcounters, 0);
  bne_PPC(CCR0, has_counters);
  call_VM(noreg, CAST_FROM_FN_PTR(address,
                                  InterpreterRuntime::build_method_counters), method, false);
  ld_PPC(Rcounters, in_bytes(Method::method_counters_offset()), method);
  cmpdi_PPC(CCR0, Rcounters, 0);
  beq_PPC(CCR0, skip); // No MethodCounters, OutOfMemory.
  BLOCK_COMMENT("} Load and ev. allocate counter object");

  bind(has_counters);
}

void InterpreterMacroAssembler::increment_invocation_counter(Register Rcounters,
                                                             Register iv_be_count,
                                                             Register Rtmp_r0) {
  assert(UseCompiler || LogTouchedMethods, "incrementing must be useful");
  Register invocation_count = iv_be_count;
  Register backedge_count   = Rtmp_r0;
  int delta = InvocationCounter::count_increment;

  // Load each counter in a register.
  //  ld_PPC(inv_counter, Rtmp);
  //  ld_PPC(be_counter, Rtmp2);
  int inv_counter_offset = in_bytes(MethodCounters::invocation_counter_offset() +
                                    InvocationCounter::counter_offset());
  int be_counter_offset  = in_bytes(MethodCounters::backedge_counter_offset() +
                                    InvocationCounter::counter_offset());

  BLOCK_COMMENT("Increment profiling counters {");

  // Load the backedge counter.
  lwz_PPC(backedge_count, be_counter_offset, Rcounters); // is unsigned int
  // Mask the backedge counter.
  andi_PPC(backedge_count, backedge_count, InvocationCounter::count_mask_value);

  // Load the invocation counter.
  lwz_PPC(invocation_count, inv_counter_offset, Rcounters); // is unsigned int
  // Add the delta to the invocation counter and store the result.
  addi_PPC(invocation_count, invocation_count, delta);
  // Store value.
  stw_PPC(invocation_count, inv_counter_offset, Rcounters);

  // Add invocation counter + backedge counter.
  add_PPC(iv_be_count, backedge_count, invocation_count);

  // Note that this macro must leave the backedge_count + invocation_count in
  // register iv_be_count!
  BLOCK_COMMENT("} Increment profiling counters");
}

void InterpreterMacroAssembler::verify_oop(Register reg, TosState state) {
  if (state == atos) { MacroAssembler::verify_oop(reg); }
}

// Local helper function for the verify_oop_or_return_address macro.
static bool verify_return_address(Method* m, int bci) {
#ifndef PRODUCT
  address pc = (address)(m->constMethod()) + in_bytes(ConstMethod::codes_offset()) + bci;
  // Assume it is a valid return address if it is inside m and is preceded by a jsr.
  if (!m->contains(pc))                                            return false;
  address jsr_pc;
  jsr_pc = pc - Bytecodes::length_for(Bytecodes::_jsr);
  if (*jsr_pc == Bytecodes::_jsr   && jsr_pc >= m->code_base())    return true;
  jsr_pc = pc - Bytecodes::length_for(Bytecodes::_jsr_w);
  if (*jsr_pc == Bytecodes::_jsr_w && jsr_pc >= m->code_base())    return true;
#endif // PRODUCT
  return false;
}

void InterpreterMacroAssembler::verify_FPU(int stack_depth, TosState state) {
  if (VerifyFPU) {
    unimplemented("verfiyFPU");
  }
}

void InterpreterMacroAssembler::verify_oop_or_return_address(Register reg, Register Rtmp) {
  if (!VerifyOops) return;

  // The VM documentation for the astore[_wide] bytecode allows
  // the TOS to be not only an oop but also a return address.
  Label test;
  Label skip;
  // See if it is an address (in the current method):

  const int log2_bytecode_size_limit = 16;
  srdi__PPC(Rtmp, reg, log2_bytecode_size_limit);
  bne_PPC(CCR0, test);

  address fd = CAST_FROM_FN_PTR(address, verify_return_address);
  const int nbytes_save = MacroAssembler::num_volatile_regs * 8;
  save_volatile_gprs(R1_SP_PPC, -nbytes_save); // except R0
  save_LR_CR(Rtmp); // Save in old frame.
  push_frame_reg_args(nbytes_save, Rtmp);

  load_const_optimized(Rtmp, fd, R0);
  mv_if_needed(R4_ARG2_PPC, reg);
  mr_PPC(R3_ARG1_PPC, R27_method);
  call_c(Rtmp); // call C

  pop_C_frame();
  restore_volatile_gprs(R1_SP_PPC, -nbytes_save); // except R0
  b_PPC(skip);

  // Perform a more elaborate out-of-line call.
  // Not an address; verify it:
  bind(test);
  verify_oop(reg);
  bind(skip);
}

// Inline assembly for:
//
// if (thread is in interp_only_mode) {
//   InterpreterRuntime::post_method_entry();
// }
// if (*jvmpi::event_flags_array_at_addr(JVMPI_EVENT_METHOD_ENTRY ) ||
//     *jvmpi::event_flags_array_at_addr(JVMPI_EVENT_METHOD_ENTRY2)   ) {
//   SharedRuntime::jvmpi_method_entry(method, receiver);
// }
void InterpreterMacroAssembler::notify_method_entry() {
  // JVMTI
  // Whenever JVMTI puts a thread in interp_only_mode, method
  // entry/exit events are sent for that thread to track stack
  // depth. If it is possible to enter interp_only_mode we add
  // the code to check if the event should be sent.
  if (JvmtiExport::can_post_interpreter_events()) {
    Label jvmti_post_done;
    Register Rscratch = R5_scratch1;

    lwu(Rscratch, R24_thread, in_bytes(JavaThread::interp_only_mode_offset()));
    beqz(Rscratch, jvmti_post_done);
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_method_entry),
            /*check_exceptions=*/true);

    bind(jvmti_post_done);
  }
}

// Inline assembly for:
//
// if (thread is in interp_only_mode) {
//   // save result
//   InterpreterRuntime::post_method_exit();
//   // restore result
// }
// if (*jvmpi::event_flags_array_at_addr(JVMPI_EVENT_METHOD_EXIT)) {
//   // save result
//   SharedRuntime::jvmpi_method_exit();
//   // restore result
// }
//
// Native methods have their result stored in d_tmp and l_tmp.
// Java methods have their result stored in the expression stack.
void InterpreterMacroAssembler::notify_method_exit(bool is_native_method, TosState state,
                                                   NotifyMethodExitMode mode, bool check_exceptions) {
  // JVMTI
  // Whenever JVMTI puts a thread in interp_only_mode, method
  // entry/exit events are sent for that thread to track stack
  // depth. If it is possible to enter interp_only_mode we add
  // the code to check if the event should be sent.
  if (mode == NotifyJVMTI && JvmtiExport::can_post_interpreter_events()) {
    Label jvmti_post_done;
    Register Rscratch = R5_scratch1;

    lwu(Rscratch, R24_thread, in_bytes(JavaThread::interp_only_mode_offset()));
    beqz(Rscratch, jvmti_post_done);
    if (!is_native_method) { push(state); } // Expose tos to GC.
    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::post_method_exit),
            /*check_exceptions=*/check_exceptions);
    if (!is_native_method) { pop(state); }

    align(32, 12);
    bind(jvmti_post_done);
  }

  // Dtrace support not implemented.
}
